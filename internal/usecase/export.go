package usecase

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/DementevVV/commitsum/internal/domain/entity"
)

// ExportUseCase handles export-related business logic.
type ExportUseCase struct{}

// NewExportUseCase creates a new ExportUseCase.
func NewExportUseCase() *ExportUseCase {
	return &ExportUseCase{}
}

// ExportToText generates plain text output.
func (uc *ExportUseCase) ExportToText(commits map[string][]entity.Commit, selected map[string]bool, dateStr string, stats *entity.Statistics) string {
	var output strings.Builder
	output.WriteString("Commit Summary - " + dateStr + "\n\n")

	repos := getSelectedReposSorted(commits, selected)
	for _, repo := range repos {
		repoCommits := commits[repo]
		output.WriteString(fmt.Sprintf("[%s]\n", repo))
		for _, commit := range repoCommits {
			output.WriteString(fmt.Sprintf("  - %s\n", commit.Message))
		}
		output.WriteString("\n")
	}

	if stats != nil {
		output.WriteString("---\n")
		output.WriteString(fmt.Sprintf("Statistics: %d commits across %d repositories\n", stats.TotalCommits, stats.TotalRepositories))
		if stats.MostActiveRepo != "" {
			output.WriteString(fmt.Sprintf("Most active: %s (%d commits)\n", stats.MostActiveRepo, stats.MaxCommits))
		}
	}

	return output.String()
}

// ExportToMarkdown generates markdown output.
func (uc *ExportUseCase) ExportToMarkdown(commits map[string][]entity.Commit, selected map[string]bool, dateStr string, stats *entity.Statistics) string {
	var output strings.Builder
	output.WriteString("# Commit Summary\n\n")
	output.WriteString(fmt.Sprintf("**Date:** %s\n\n", dateStr))

	if stats != nil {
		output.WriteString("## Statistics\n\n")
		output.WriteString(fmt.Sprintf("- **Total Commits:** %d\n", stats.TotalCommits))
		output.WriteString(fmt.Sprintf("- **Repositories:** %d\n", stats.TotalRepositories))
		if stats.MostActiveRepo != "" {
			output.WriteString(fmt.Sprintf("- **Most Active:** %s (%d commits)\n", stats.MostActiveRepo, stats.MaxCommits))
		}
		output.WriteString("\n")
	}

	output.WriteString("## Commits\n\n")

	repos := getSelectedReposSorted(commits, selected)
	for _, repo := range repos {
		repoCommits := commits[repo]
		output.WriteString(fmt.Sprintf("### %s\n\n", repo))
		for _, commit := range repoCommits {
			output.WriteString(fmt.Sprintf("- %s\n", commit.Message))
		}
		output.WriteString("\n")
	}

	output.WriteString("---\n")
	output.WriteString(fmt.Sprintf("*Generated by commitsum on %s*\n", time.Now().Format("2006-01-02 15:04:05")))

	return output.String()
}

// ExportToJSON generates JSON output.
func (uc *ExportUseCase) ExportToJSON(commits map[string][]entity.Commit, selected map[string]bool, dateStr string, stats *entity.Statistics) (string, error) {
	export := entity.NewSummaryExport(dateStr)
	export.Stats = stats

	repos := getSelectedReposSorted(commits, selected)
	for _, repo := range repos {
		repoCommits := commits[repo]
		export.TotalRepos++
		for _, commit := range repoCommits {
			export.Commits[repo] = append(export.Commits[repo], entity.CommitExport{
				Repository: repo,
				Message:    commit.Message,
			})
			export.TotalCommits++
		}
	}

	data, err := json.MarshalIndent(export, "", "  ")
	if err != nil {
		return "", err
	}

	return string(data), nil
}

// ExportWithTemplate generates output using a custom template.
func (uc *ExportUseCase) ExportWithTemplate(commits map[string][]entity.Commit, selected map[string]bool, dateStr string, stats *entity.Statistics, tmplStr string) (string, error) {
	data := struct {
		Date    string
		Commits map[string][]entity.Commit
		Stats   *entity.Statistics
	}{
		Date:    dateStr,
		Commits: make(map[string][]entity.Commit),
		Stats:   stats,
	}

	for repo, repoCommits := range commits {
		if selected[repo] {
			data.Commits[repo] = repoCommits
		}
	}

	tmpl, err := template.New("summary").Parse(tmplStr)
	if err != nil {
		return "", fmt.Errorf("invalid template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("template execution failed: %w", err)
	}

	return buf.String(), nil
}

// SaveToFile saves content to a file.
func (uc *ExportUseCase) SaveToFile(content, filename string) error {
	dir := filepath.Dir(filename)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	return os.WriteFile(filename, []byte(content), 0644)
}

// GenerateFilename generates a filename based on date and format.
func (uc *ExportUseCase) GenerateFilename(startDate string, format entity.ExportFormat) string {
	ext := ".txt"
	switch format {
	case entity.FormatMarkdown:
		ext = ".md"
	case entity.FormatJSON:
		ext = ".json"
	}
	return fmt.Sprintf("commits-%s%s", startDate, ext)
}

// getSelectedReposSorted returns a sorted slice of selected repository names.
func getSelectedReposSorted(commits map[string][]entity.Commit, selected map[string]bool) []string {
	var repos []string
	for repo := range commits {
		if selected[repo] {
			repos = append(repos, repo)
		}
	}
	sort.Strings(repos)
	return repos
}

// DefaultTemplates provides some built-in templates.
var DefaultTemplates = map[string]string{
	"simple": `Commits for {{.Date}}
{{range $repo, $commits := .Commits}}
[{{$repo}}]
{{range $commits}}  - {{.Message}}
{{end}}{{end}}`,

	"detailed": `Daily Commit Report
Date: {{.Date}}
{{if .Stats}}
Total: {{.Stats.TotalCommits}} commits in {{.Stats.TotalRepositories}} repos
{{end}}
{{range $repo, $commits := .Commits}}
{{$repo}}
{{range $commits}}- {{.Message}}
{{end}}
{{end}}`,

	"slack": `*Commit Summary - {{.Date}}*
{{range $repo, $commits := .Commits}}
*{{$repo}}*
{{range $commits}}* {{.Message}}
{{end}}{{end}}`,
}
